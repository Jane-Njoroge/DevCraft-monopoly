{"ast":null,"code":"class MonopolyGame {\n  constructor() {\n    this.players = [];\n    this.properties = this.createProperties(); // See function below\n    this.currentPlayerIndex = 0;\n    this.gameOver = false;\n  }\n  addPlayer(player) {\n    this.players.push(player);\n  }\n  createProperties() {\n    // Simplified property data (expand as needed)\n    return [{\n      name: \"Mediterranean Avenue\",\n      price: 60,\n      owner: null\n    }, {\n      name: \"Baltic Avenue\",\n      price: 60,\n      owner: null\n    },\n    // ... more properties\n    {\n      name: \"Boardwalk\",\n      price: 400,\n      owner: null\n    }];\n  }\n  playTurn() {\n    const currentPlayer = this.players[this.currentPlayerIndex];\n    // ... (Dice roll, move player, handle property interactions, etc.)\n    this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.players.length; // Cycle through players\n\n    if (this.checkGameOver()) {\n      this.endGame();\n    }\n  }\n  checkGameOver() {\n    // Basic game over condition (e.g., only one player left with money)\n    return this.players.filter(p => p.money > 0).length <= 1;\n  }\n  endGame() {\n    this.gameOver = true;\n    // Announce winner, display scores, etc.\n    console.log(\"Game Over!\");\n  }\n\n  // ... (More game logic: buying properties, trading, going to jail, etc.)\n}\nclass Player {\n  constructor(name, money) {\n    this.name = name;\n    this.money = money;\n    this.properties = []; // Properties the player owns\n    this.position = 0; // Starting position on the board\n  }\n  buyProperty(property) {\n    if (this.money >= property.price) {\n      this.money -= property.price;\n      this.properties.push(property);\n      property.owner = this;\n      console.log(`${this.name} bought ${property.name}`);\n    } else {\n      console.log(`${this.name} doesn't have enough money to buy ${property.name}`);\n    }\n  }\n\n  // ... (Other player actions: rolling dice, paying rent, etc.)\n}\n\n// Example usage:\nconst game = new MonopolyGame();\nconst player1 = new Player(\"Alice\", 1500);\nconst player2 = new Player(\"Bob\", 1500);\ngame.addPlayer(player1);\ngame.addPlayer(player2);\ngame.playTurn(); // Start the game loop (you'll need to implement the turn logic)\n\nplayer1.buyProperty(game.properties[0]); // Alice buys Mediterranean Avenue\nplayer2.buyProperty(game.properties[1]); // Bob buys Baltic Avenue\n\n// ... (Continue playing the game)\n\n// You'll need to add a lot more logic to make a full Monopoly game.\n// This is a basic framework to get you started.","map":{"version":3,"names":["MonopolyGame","constructor","players","properties","createProperties","currentPlayerIndex","gameOver","addPlayer","player","push","name","price","owner","playTurn","currentPlayer","length","checkGameOver","endGame","filter","p","money","console","log","Player","position","buyProperty","property","game","player1","player2"],"sources":["/home/wangui/Phase5/monopoly-frontend/src/components/Board.js"],"sourcesContent":["class MonopolyGame {\n  constructor() {\n    this.players = [];\n    this.properties = this.createProperties(); // See function below\n    this.currentPlayerIndex = 0;\n    this.gameOver = false;\n  }\n\n  addPlayer(player) {\n    this.players.push(player);\n  }\n\n  createProperties() {\n    // Simplified property data (expand as needed)\n    return [\n      { name: \"Mediterranean Avenue\", price: 60, owner: null },\n      { name: \"Baltic Avenue\", price: 60, owner: null },\n      // ... more properties\n      { name: \"Boardwalk\", price: 400, owner: null },\n    ];\n  }\n\n  playTurn() {\n    const currentPlayer = this.players[this.currentPlayerIndex];\n    // ... (Dice roll, move player, handle property interactions, etc.)\n    this.currentPlayerIndex =\n      (this.currentPlayerIndex + 1) % this.players.length; // Cycle through players\n\n    if (this.checkGameOver()) {\n      this.endGame();\n    }\n  }\n\n  checkGameOver() {\n    // Basic game over condition (e.g., only one player left with money)\n    return this.players.filter((p) => p.money > 0).length <= 1;\n  }\n\n  endGame() {\n    this.gameOver = true;\n    // Announce winner, display scores, etc.\n    console.log(\"Game Over!\");\n  }\n\n  // ... (More game logic: buying properties, trading, going to jail, etc.)\n}\n\nclass Player {\n  constructor(name, money) {\n    this.name = name;\n    this.money = money;\n    this.properties = []; // Properties the player owns\n    this.position = 0; // Starting position on the board\n  }\n\n  buyProperty(property) {\n    if (this.money >= property.price) {\n      this.money -= property.price;\n      this.properties.push(property);\n      property.owner = this;\n      console.log(`${this.name} bought ${property.name}`);\n    } else {\n      console.log(\n        `${this.name} doesn't have enough money to buy ${property.name}`\n      );\n    }\n  }\n\n  // ... (Other player actions: rolling dice, paying rent, etc.)\n}\n\n// Example usage:\nconst game = new MonopolyGame();\nconst player1 = new Player(\"Alice\", 1500);\nconst player2 = new Player(\"Bob\", 1500);\n\ngame.addPlayer(player1);\ngame.addPlayer(player2);\n\ngame.playTurn(); // Start the game loop (you'll need to implement the turn logic)\n\nplayer1.buyProperty(game.properties[0]); // Alice buys Mediterranean Avenue\nplayer2.buyProperty(game.properties[1]); // Bob buys Baltic Avenue\n\n// ... (Continue playing the game)\n\n// You'll need to add a lot more logic to make a full Monopoly game.\n// This is a basic framework to get you started.\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}